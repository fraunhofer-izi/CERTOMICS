---
title: "Quality Control"
author: "Fraunhofer IZI"
subtitle: "CERTOMICS v1.0"
date: today
format:
  html:
    code-fold: true
    theme: lux
    fig-width: 8
    fig-height: 6
execute:
  echo: true
  warning: true
  error: true
  debug: true
params:
  kallisto_matrix: "" #'CAR_est_counts_matrix.csv'
  results_metrics_reads_CAR: "" #"results_metrics_reads_CAR.csv" 
  results_coverage_against_CAR: "" #"results_coverage_against_CAR.csv"
  results_coverage_against_CAR_unique: "" #"results_coverage_against_CAR_unique.csv"
  gtf: "" #"Anno_Axicel.gtf"
  seurat_object: "" #"merged_seurat.rds"
  libraries: "" # example "1110" #flags according to use GEX, VDJT, VDJB, AntibodyCapture
resources:
  - coverage_plot.html
---

```{r}
#| label: load-packages
#| include: false
#| warning: false
#| eval: true

#set cran packages
.cran_packages = c(
  "yaml", "dplyr", "tidyr", "stringr", "data.table", "ggplot2", "ggthemes", "crosstalk", "plotly", "htmlwidgets",
  "htmltools", "reticulate", "Seurat", "patchwork", "knitr"
)
#set bioconductor packages
.bioc_packages = c()
list.of.packages = c(.cran_packages, .bioc_packages)

## Loading library
for (pack in list.of.packages) {
  suppressMessages(library(
    pack,
    quietly = TRUE,
    verbose = FALSE,
    character.only = TRUE
  ))
}
library("reticulate")
source("helper_functions.R")
use_python("/homes/olymp/christina.kuhn/.conda/envs/LivingDrugOmics/bin/python3", required=TRUE)
# use_python("/usr/bin/python3", required = TRUE) 
```

:::{.panel-tabset .nav-pills}
# CAR-level metrics

::: {.callout-note collapse="true"}
## All plots are generated using filtered seurat object. Click to expand filtering criteria and cell numbers

### Filtering criteria applied:
- **Feature Count**:
  - Lower: `nFeature_low_cutoff = 250`
  - Upper: `nFeature_high_cutoff = 8000`
- **UMI Count**:
  - Lower: `nCount_low_cutoff = 1000`
  - Upper: `nCount_high_cutoff = 100000`
- **Mitochondrial Content**: `mt_cutoff = 15`
- **Complexity Score**: `complx_cutoff = 0.8`
- **Doublet Removal**: `scDblFinder_class == "doublet"`

```{r}
#| label: set-flags-r
#| echo: false
#| warning: false
#| message: false
#| eval: true

# Get paramters
seurat_object <- params$seurat_object
libraries <- params$libraries
flags <- parse_binary_string(libraries)

# Load Seurat object
seu.obj <- readRDS(seurat_object)
# Count cells per sample before filtering
cells_per_sample_before <- as.data.frame(table(seu.obj$orig.ident))
colnames(cells_per_sample_before) <- c("Sample", "Cells_Before_Filtering")

# Subset the Seurat object safely
seu.obj.filtered <- tryCatch({
  subset(seu.obj, subset = KEEP_CELL == TRUE)
}, error = function(e) {
  message("No cells passed the filtering condition. Returning NULL.")
  return(NULL)  # Ensure NULL is returned properly
})

# Prepare data table for cell counts summary
if (!is.null(seu.obj.filtered)) {
  # If filtering was successful, retrieve metadata and count cells per sample
  meta_data <- seu.obj.filtered@meta.data
  cells_per_sample_after <- as.data.frame(table(seu.obj.filtered$orig.ident))
} else {
  # If filtering resulted in NULL, create an empty data frame
  meta_data <- NULL
  cells_per_sample_after <- data.frame(Sample = unique(cells_per_sample_before$Sample), Cells_After_Filtering = 0)
}

# Ensure consistent merging, filling NA values with 0
colnames(cells_per_sample_after) <- c("Sample", "Cells_After_Filtering")
cell_counts_summary <- merge(cells_per_sample_before, cells_per_sample_after, by = "Sample", all = TRUE)
cell_counts_summary[is.na(cell_counts_summary)] <- 0

```

```{r}
#| label: cell-counts-table
#| echo: false
#| message: false
#| warning: false
#| results: asis

library(knitr)
kable(cell_counts_summary, caption = "Number of Cells Per Sample Before and After Filtering")
```

:::

```{r}
#| label: QC-Alert
#| echo: false
#| warning: false
#| results: asis
#| eval: !expr (is.null(meta_data))

if (is.null(meta_data)) {
  cat("
::: {.alert .alert-warning}
⚠️ **Warning:** No cells passed the filtering condition. See filtering criteria above.
:::
")
}
```


```{r}
#| label: QC-Alert-CAR
#| echo: false
#| warning: false
#| results: asis
#| eval: !expr (params$gtf == "none")

if (is.null(meta_data)) {
  cat("
::: {.alert .alert-warning}
⚠️ **Warning:** No CAR construct was given. CAR-specific metrices not available.
:::
")
}
```


## Read-level

```{python}
#| label: set-flags-python
#| echo: false
#| eval: true
#| warning: false

def parse_binary_string(binary_string):
    # Ensure the binary string has at least 7 characters by padding with '0' to the right
    binary_string = str(binary_string).ljust(7, '0')

    # Return a dictionary of booleans corresponding to each position in the binary string
    return {
        'GEX': binary_string[0] == '1',
        'VDJT': binary_string[1] == '1',
        'VDJB': binary_string[2] == '1',
        'AntibodyCapture': binary_string[3] == '1'
    }

flags = parse_binary_string(r.params['libraries'])
```


```{python}
#| label: plot-kallisto-metrics-across-car-constructs
#| fig-cap: "Estimated read counts for different CAR constructs across samples, using kallisto."
#| echo: false
#| eval: !expr (params$kallisto_matrix != "" && file.exists(params$kallisto_matrix))
#| warning: false
#| results: "hide"

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
count_df = pd.read_csv(r.params['kallisto_matrix'], index_col=0)

# --- Grouped Bar Plot ---
samples = count_df.index.tolist()
cars = count_df.columns.tolist()
x = np.arange(len(samples))
bar_width = 0.8 / len(cars)

fig, ax = plt.subplots(figsize=(14, 6))

for i, car in enumerate(cars):
    ax.bar(x + i * bar_width, count_df[car], width=bar_width, label=car)

# Centered xticks for grouped bars
ax.set_xticks(x + bar_width * (len(cars) - 1) / 2)
ax.set_xticklabels(samples, rotation=45, fontsize=16)

# Axis labels & title with larger font
ax.set_xlabel("Sample", fontsize24)
ax.set_ylabel("Estimated Read Counts", fontsize=16)

# Increase tick label sizes
ax.tick_params(axis='y', labelsize=16)

# Hide top and right spines only
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

# Legend with bigger font
ax.legend(title="CAR", fontsize=16, title_fontsize=16, framealpha=0.7)

plt.tight_layout()
plt.show()

```

```{python}
#| label: coverage-plot
#| fig-cap: "Read coverage across the CAR construct is given. The x-axis presents nucleotide position within the CAR construct, while the y-axis shows the number of reads mapping to each nucleotide position. Coverage is depicted for two categories: uniquely mapped reads (in blue) and all mapped reads (in purple), which include both uniquely and multimapped reads, as determined by the STAR aligner."
#| echo: false
#| eval: !expr (params["gtf"] != "none")
#| warning: false
import CAR_quality_plot
if flags["GEX"]:
  read_metrics, cov_all, cov_unique = CAR_quality_plot.read_data(\
          r.params['results_metrics_reads_CAR'], r.params['results_coverage_against_CAR'], r.params['results_coverage_against_CAR_unique'])

  CAR_quality_plot.plot_coverage(cov_all, cov_unique, r.params["gtf"])
```

```{=html}
<!--| eval: !expr (params["gtf"] != "none") -->
<iframe src="coverage_plot.html" width="100%" height="600px" frameborder="0"></iframe>
<figcaption class="figure-caption" style="text-align: left; margin-top: 0.5em;">
  Read coverage across the CAR construct is given. The x-axis presents nucleotide position within the CAR construct, while the y-axis shows the number of reads mapping to each nucleotide position. Coverage is depicted for two categories: uniquely mapped reads (in blue) and all mapped reads (in purple), which include both uniquely and multimapped reads, as determined by the STAR aligner.
</figcaption>
```

<br>

```{python}
#| label: read-metrics
#| fig-cap: "Absolute Number of reads mapping against CAR construct."
#| echo: false
#| eval: !expr (params["gtf"] != "none")
#| warning: false
#| fig-height: 4

if flags["GEX"]:
  CAR_quality_plot.plot_read_metrices(read_metrics)
```

## Count-level

```{r}
#| label: count-level-plots-t
#| fig-cap: "Percentage of CAR-positive cells (count>0) compared to all T cells (CD4, CD8, gdT, multi) (based on scGate annotation). Absolute counts of are displayed on top of the bars (frequency under 1% are not labeled)."
#| echo: false
#| warning: false
#| eval: !expr (params$gtf != "none")
#| fig-height: 4

# Custom general theme
theme_custom <- function(base_size = 10, base_family = "") {
  theme_minimal(base_size = base_size, base_family = base_family) +
    theme(
      axis.title = element_text(size = base_size + 2),
      axis.text = element_text(size = base_size),
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.title = element_text(size = base_size + 1),
      legend.text = element_text(size = base_size - 2),
      plot.title = element_text(size = base_size + 2, face = "bold", hjust = 0.5),
      strip.text = element_text(size = base_size + 1)  # For facets
    )
}

car_construct_path = params$gtf
lines <- readLines(car_construct_path)

# Extract the first line
first_line <- lines[1]
# Extract the first word of the first line
car_construct <- strsplit(first_line, "\\s+")[[1]][1]

if (flags$GEX && params$gtf != "none" && !is.null(meta_data)){
  # Step 1: Filter for pure T cells
  t_cell_data <- meta_data %>%
    filter(is.pure_CD8T == "Pure" | is.pure_CD4T == "Pure" | is.pure_gdT == "Pure")

  # Step 2: Total T cells per sample
  total_t_cells <- t_cell_data %>%
    group_by(orig.ident) %>%
    summarise(total_T = n(), .groups = "drop")

  # Step 3: CAR+ CD4 and CD8 counts per sample
  car_t_cells <- t_cell_data %>%
    filter(T_CAR == TRUE) %>%
    mutate(T_cell_type = case_when(
      scGate_multi == "CD4T" ~ "CD4",
      scGate_multi == "CD8T" ~ "CD8",
      scGate_multi == "gdT" ~ "gdT",
      TRUE ~ "Multi"
    )) %>%
    filter(!is.na(T_cell_type)) %>%
    group_by(orig.ident, T_cell_type) %>%
    summarise(CAR_count = n(), .groups = "drop")

  # Step 4: Merge and calculate % of all T cells
  car_percent <- car_t_cells %>%
    left_join(total_t_cells, by = "orig.ident") %>%
    mutate(percentage = (CAR_count / total_T) * 100)

  car_percent <- car_percent %>%
    mutate(
      text_color = case_when(
        T_cell_type %in% c("CD4", "gdT", "Multi") ~ "black",
        TRUE ~ "white"
      )
    )
  car_percent <- car_percent %>%
  mutate(show_label = ifelse(percentage <= 1, NA, CAR_count))
  # Step 5: Create stacked barplot
  plot_car_proportion <- ggplot(car_percent, aes(x = orig.ident, y = percentage, fill = T_cell_type)) +
    geom_bar(stat = "identity") +
    geom_text(
      aes(label = show_label, color = text_color),
      position = position_stack(vjust = 0.5),
      size = 3,
      fontface = "bold"
    ) +
    scale_fill_manual(
      values = c(
        "CD4" = "#6FC1CD",
        "CD8" = "#005B7F",
        "gdT" = "#FF7F00",
        "Multi" = "grey"
      )
    ) +
    scale_color_identity(guide = "none") +  # Directly uses the color value without legend
    labs(
      title = "CAR+ T Cells",
      x = "Sample",
      y = "CAR+ Cells (%)",
      fill = "T cell type"
    ) +
    scale_y_continuous(limits = c(0, 100), expand = c(0, 0)) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +  theme_custom(base_size = 10)  # Apply the general theme

  ggsave("test.png",plot_car_proportion)
  print(plot_car_proportion)
}
```


```{r}
#| label: count-level-plots-nk
#| fig-cap: "Percentage of CAR-positive cells (count>0) compared to all NK cells (based on scGate annotation). Absolute counts of are displayed on top of the bars."
#| echo: false
#| warning: false
#| eval: !expr (params$gtf != "none")
#| fig-height: 4

if (flags$GEX && params$gtf != "none" && !is.null(meta_data)){
  # Step 1: Filter for pure T cells
  nk_cell_data <- meta_data %>%
    filter(is.pure_NK == "Pure")

  # Summarize per sample
  nk_summary <- nk_cell_data %>%
    group_by(orig.ident) %>%
    summarise(
      total_nk = n(),
      car_pos_nk = sum(CAR_BY_EXPRS == TRUE),
      car_pos_fraction = car_pos_nk / total_nk,
      car_pos_percent = 100 * car_pos_fraction
    )

  # Step 5: Create stacked barplot
  plot_nk_car_percent <- ggplot(nk_summary, aes(x = orig.ident, y = car_pos_percent)) +
  geom_bar(stat = "identity", fill = "lightgrey") +
  geom_text(
    aes(label = car_pos_nk),
    vjust = -0.3,
    size = 3,
    fontface = "bold"
  ) +
  scale_y_continuous(limits = c(0, 100), expand = c(0, 0)) +
  labs(
    title = "CAR+ NK Cells",
    x = "Sample",
    y = "CAR+ NK Cells (%)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme_custom(base_size = 10)

  print(plot_nk_car_percent)
}

```

```{r}
#| label: count-level-plots-macro
#| fig-cap: "Percentage of CAR-positive cells (count>0) compared to all Macrophages (based on scGate annotation). Absolute counts of are displayed on top of the bars."
#| echo: false
#| warning: false
#| eval: !expr (params$gtf != "none")
#| fig-height: 4

if (flags$GEX && params$gtf != "none" && !is.null(meta_data)){
  # Step 1: Filter for pure T cells
  m_cell_data <- meta_data %>%
    filter(is.pure_Monocyte == "Pure")

  # Summarize per sample
  m_summary <- m_cell_data %>%
    group_by(orig.ident) %>%
    summarise(
      total_m = n(),
      car_pos_m = sum(CAR_BY_EXPRS == TRUE),
      car_pos_fraction = car_pos_m / total_m,
      car_pos_percent = 100 * car_pos_fraction
    )

  # Step 5: Create stacked barplot
  plot_m_car_percent <- ggplot(m_summary, aes(x = orig.ident, y = car_pos_percent)) +
  geom_bar(stat = "identity", fill = "#A6D854") +
  geom_text(
    aes(label = car_pos_m),
    vjust = -0.3,
    size = 3,
    fontface = "bold"
  ) +
  scale_y_continuous(limits = c(0, 100), expand = c(0, 0)) +
  labs(
    title = "CAR+ Macrophages",
    x = "Sample",
    y = "CAR+ Macrophages (%)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme_custom(base_size = 10)

  print(plot_m_car_percent)
}

```


```{r}
#| label: count-level-plots-Dc
#| fig-cap: "Percentage of CAR-positive cells (count>0) compared to all Dendritic Cells (based on scGate annotation). Absolute counts of are displayed on top of the bars."
#| echo: false
#| warning: false
#| eval: !expr (params$gtf != "none")
#| fig-height: 4

if (flags$GEX && params$gtf != "none" && !is.null(meta_data)){
  # Step 1: Filter for pure T cells
  m_cell_data <- meta_data %>%
    filter(is.pure_panDC == "Pure")
  # Summarize per sample
  m_summary <- m_cell_data %>%
    group_by(orig.ident) %>%
    summarise(
      total_m = n(),
      car_pos_m = sum(CAR_BY_EXPRS == TRUE),
      car_pos_fraction = car_pos_m / total_m,
      car_pos_percent = 100 * car_pos_fraction
    )

  # Step 5: Create stacked barplot
  plot_m_car_percent <- ggplot(m_summary, aes(x = orig.ident, y = car_pos_percent)) +
  geom_bar(stat = "identity", fill = "#33A02C") +
  geom_text(
    aes(label = car_pos_m),
    vjust = -0.3,
    size = 3,
    fontface = "bold"
  ) +
  scale_y_continuous(limits = c(0, 100), expand = c(0, 0)) +
  labs(
    title = "CAR+ Dendritic Cells",
    x = "Sample",
    y = "CAR+ Dendritic Cells (%)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme_custom(base_size = 10)

  print(plot_m_car_percent)
}

```


```{r}
#| label: count-level-plots-b
#| fig-cap: "Percentage of CAR-positive cells (count>0) compared to all B cells (based on scGate annotation). Absolute counts of are displayed on top of the bars."
#| echo: false
#| warning: false
#| eval: !expr (params$gtf != "none")
#| fig-height: 4

if (flags$GEX && params$gtf != "none" && !is.null(meta_data)){
  # Step 1: Filter for pure T cells
  m_cell_data <- meta_data %>%
    filter(is.pure_Bcell == "Pure")

  # Summarize per sample
  m_summary <- m_cell_data %>%
    group_by(orig.ident) %>%
    summarise(
      total_m = n(),
      car_pos_m = sum(CAR_BY_EXPRS == TRUE),
      car_pos_fraction = car_pos_m / total_m,
      car_pos_percent = 100 * car_pos_fraction
    )

  # Step 5: Create stacked barplot
  plot_m_car_percent <- ggplot(m_summary, aes(x = orig.ident, y = car_pos_percent)) +
  geom_bar(stat = "identity", fill = "#F8766D") +
  geom_text(
    aes(label = car_pos_m),
    vjust = -0.3,
    size = 3,
    fontface = "bold"
  ) +
  scale_y_continuous(limits = c(0, 100), expand = c(0, 0)) +
  labs(
    title = "CAR+ B Cells",
    x = "Sample",
    y = "CAR+ B Cells (%)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  theme_custom(base_size = 10)

  print(plot_m_car_percent)
}

```


# GEX-specific metrices

```{r}
#| label: QC-Alert-1
#| echo: false
#| warning: false
#| results: asis
#| eval: !expr (is.null(meta_data))

if (is.null(meta_data)) {
  cat("
::: {.alert .alert-warning}
⚠️ **Warning:** No cells passed the filtering condition. See filtering criteria.
:::
")
}
```

## Cell type proportions

`r if (!flags$GEX) 'No GEX libraries were processed.'`

```{r}
#| label: GEX-metric-cell-type-composition-absolute
#| fig-cap: "Absolute number of cell types per samples, based on annotation with scGate (PBMC model)."
#| echo: false
#| eval: !expr (!is.null(meta_data))
#| warning: false
#| fig-height: 4

custom_colors <- c(
  "Bcell"                           = "#F8766D",  # Red-Orange
  "CD8T"                            = "#0A5B7C",  # Dark Blue
  "CD4T"                            = "#66A6D9",  # Light Blue
  "Erythrocyte"                     = "#990000",  # Dark Red (reflects high hemoglobin content)
  "Neutrophils"                     = "#6A3D9A",  # Purple
  "NK"                              = "#B3B3B3",  # Light Grey
  "HSPC"                            = "#E78AC3",  # Light Pink (early progenitors)
  "Mast"                            = "#FFD700",  # Gold (linked to histamine & granule release)
  "Monocyte"                        = "#A6D854",  # Bright Lime Green
  "panDC"                           = "#33A02C",  # Strong Green (DCs link innate & adaptive immunity)
  "PlasmaCell"                      = "#8B0000",  # Dark Maroon (high antibody secretion)
  "Platelet"                        = "#E31A1C",  # Strong Red
  "gdT"                             = "#FF7F00",  # Orange (bridge between innate & adaptive)
  "NA"                              = "#BBBBBB",  # Grey (uncertain classification)
  "Multi"                           = "black"     # Black (indicates ambiguous classification)
)


if (flags$GEX){
  # Get number of each cloneSize
  result <- meta_data %>%
    group_by(orig.ident, scGate_multi) %>%
    summarize(cell_count = n(), .groups = "drop")  # Count absolute numbers

  # Create the stacked bar plot with absolute counts
  stacked_bar_absolute_plot <- ggplot(result, aes(x = orig.ident, y = cell_count, fill = scGate_multi)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = custom_colors) +
    labs(
        x = "Sample",
        y = "Number of Cells",
        fill = "Cell Types"  # Change legend title
    ) +
    theme_minimal() +
    theme_custom(base_size = 10)  # Apply the general theme

  print(stacked_bar_absolute_plot)
}
```

<br>

```{r}
#| label: GEX-metric-cell-type-composition-relative
#| fig-cap: "Relative number of cell types per samples, based on annotation with scGate (PBMC model)."
#| echo: false
#| eval: !expr (!is.null(meta_data))
#| warning: false
#| fig-height: 4

if (flags$GEX) {
  result <- meta_data %>%
    group_by(orig.ident, scGate_multi) %>%
    summarize(cell_count = n()) %>%
    ungroup() %>%
    group_by(orig.ident) %>%
    mutate(total_cells = sum(cell_count),
          proportion = (cell_count / total_cells) * 100)  # Calculate proportion

  # Create the stacked bar plot
  stacked_bar_plot <- ggplot(result, aes(x = orig.ident, y = proportion, fill = scGate_multi)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = custom_colors) +
    labs(
        x = "Sample",
        y = "Percentage of cells (%)",
        fill = "Cell Types"  # Change legend title here
    ) +
    theme_minimal() +
    theme_custom(base_size = 10)  # Apply the general theme

  print(stacked_bar_plot)
}
```

# VDJ-specific metrices

```{r}
#| label: QC-Alert-2
#| echo: false
#| warning: false
#| results: asis
#| eval: !expr (is.null(meta_data))

if (is.null(meta_data)) {
  cat("
::: {.alert .alert-warning}
⚠️ **Warning:** No cells passed the filtering condition. See filtering criteria.
:::
")
}
```

## T-cell

### Clonotype composition

`r if (!flags$VDJT) 'No VDJ-T libraries were processed.'`

::: {.callout-note collapse="true"}
## Click to expand a table showing the clonal frequency ranges for each clone-size category.

```{r}
#| label: VDJ-metric-T-cell-clonotypes-table
#| echo: false
#| warning: false
#| eval: !expr (!is.null(meta_data))

if (flags$VDJT){
  # Create a copy of meta_data and remove rows where cloneSize is NA
  meta_data_filtered <- meta_data %>%
    filter(VDJ_T_AVAIL == TRUE & !is.na(cloneSize))
  # Berechne den minimalen und maximalen clonalFrequency-Wert für jede Clone-Size-Kategorie
  clone_size_ranges <- meta_data_filtered %>%
        group_by(cloneSize) %>%
        summarise(
          min_clonalFrequency = min(clonalFrequency, na.rm = TRUE),
          max_clonalFrequency = max(clonalFrequency, na.rm = TRUE)
        )

  clone_size_ranges %>%
    kable(caption = "Clonal Frequency Ranges by Clone-Size Category")
}
```

:::

```{r}
#| label: VDJ-metric-T-cell-clonotypes-absolute
#| fig-cap: "Absolute number of unique clonotypes per sample, categorized by expansion levels (e.g., hyperexpanded, large, medium, small, single)."
#| echo: false
#| warning: false
#| eval: !expr (!is.null(meta_data))
#| fig-height: 4

if (flags$VDJT){
  # Define the full mapping of cloneSize levels and corresponding colors
  custom_colors <- c(
    "Hyperexpanded (>0.1)"          = "#B83B5E",  # Hyperexpanded (Red)
    "Large (0.01 < X <= 0.1)"       = "#F08A5D",  # Large (Orange)
    "Medium (0.001 < X <= 0.01)"    = "#A0DEFF",  # Medium (Yellowish)
    "Small (1e-04 < X <= 0.001)"    = "#5AB2FF",  # Small (Light Blue)
    "Rare (0 < X <= 1e-04)"         = "#7F7F7F"   # Single (Dark Blue),
  )
  # Create a named vector of all levels and colors
  unqiue_clonotypes_sizes <- unique(meta_data_filtered$cloneSize)
  clono.col <- custom_colors[names(custom_colors) %in% unqiue_clonotypes_sizes]

  clone_size_counts <- meta_data_filtered %>%
    group_by(orig.ident, cloneSize) %>%
    summarise(count = n_distinct(CTstrict), .groups = 'drop')  # Count unique clonotypes

  # Plot absolute number of clonotypes
  plot_clone_size_absolute <- ggplot(clone_size_counts, aes(x = orig.ident, y = count, fill = cloneSize)) +
    geom_bar(stat = "identity") +
    labs(
      x = "Sample",
      y = "Absolute number of unique clonotypes",
      fill = "Clone size"  # Change legend title
    ) +
    theme_minimal() +
    scale_fill_manual(values = clono.col) +  theme_custom(base_size = 10)  # Apply the general theme  # Drops unused categories from the legend

  print(plot_clone_size_absolute)
}

```

<br>

```{r}
#| label: VDJ-metric-T-cell-clonotypes-relatives
#| fig-cap: "Relative number of clonotypes per sample, categorized by expansion levels (e.g., hyperexpanded, large, medium, small, single)."
#| echo: false
#| eval: !expr (!is.null(meta_data))
#| warning: false
#| fig-height: 4

if (flags$VDJT){
  # Count the number of cells per cloneSize per sample
  clone_size_counts <- meta_data_filtered %>%
    group_by(orig.ident, cloneSize) %>%
    summarise(count = n_distinct(CTstrict), .groups = 'drop')  # Count unique clonotypes

  # Calculate percentages within each sample
  clone_size_percent <- clone_size_counts %>%
    group_by(orig.ident) %>%
    mutate(percentage = (count / sum(count)) * 100)

  plot_clone_size_percentage <- ggplot(clone_size_percent, aes(x = orig.ident, y = percentage, fill = cloneSize)) +
    geom_bar(stat = "identity") +  # Stacked bars with proportion scaling
    scale_y_continuous(labels = scales::percent_format(scale = 1)) +  # Convert to percentage
    scale_fill_manual(values = clono.col) +  # Use predefined colors
    labs(x = "Sample",
        y = "Percentage of Cells",
        fill = "Clone Size") +
    theme_minimal() +
    theme_custom(base_size = 10)  # Apply the general theme

  print(plot_clone_size_percentage)
}
```

## B-cell

### Clonotype composition

`r if (!flags$VDJB) 'No VDJ-B libraries were processed.'`

::: {.callout-note collapse="true"}
## Click to expand a table showing the clonal frequency ranges for each clone-size category.

```{r}
#| label: VDJ-metric-B-cell-clonotypes-table
#| echo: false
#| eval: !expr (!is.null(meta_data))
#| warning: false

if (flags$VDJB){
  meta_data_filtered <- meta_data %>%
      filter(VDJ_B_AVAIL == TRUE & !is.na(cloneSize))

  # Berechne den minimalen und maximalen clonalFrequency-Wert für jede Clone-Size-Kategorie
  clone_size_ranges <- meta_data_filtered %>%
        group_by(cloneSize) %>%
        summarise(
          min_clonalFrequency = min(clonalFrequency, na.rm = TRUE),
          max_clonalFrequency = max(clonalFrequency, na.rm = TRUE)
        )

  clone_size_ranges %>%
    kable(caption = "Clonal Frequency Ranges by Clone-Size Category")
}
```

:::

```{r}
#| label: VDJ-metric-B-cell-clonotypes-absolute
#| fig-cap: "Absolute number of clonotypes per sample, categorized by expansion levels (e.g., hyperexpanded, large, medium, small, single)."
#| echo: false
#| warning: false
#| eval: !expr (!is.null(meta_data))
#| fig-height: 4

if (flags$VDJB){
  # Create a named vector of all levels and colors
  unqiue_clonotypes_sizes <- unique(meta_data_filtered$cloneSize)
  clono.col <- custom_colors[names(custom_colors) %in% unqiue_clonotypes_sizes]

  # Get number of each cloneSize
  clone_size_counts <- meta_data_filtered %>%
    group_by(orig.ident, cloneSize) %>%
    summarise(count = n_distinct(CTstrict), .groups = 'drop')  # Count unique clonotypes

  # Plot absolute number of clonotypes
  plot_clone_size_absolute <- ggplot(clone_size_counts, aes(x = orig.ident, y = count, fill = cloneSize)) +
    geom_bar(stat = "identity") +
    labs(
      x = "Sample",
      y = "Absolute number of unique clonotypes",
      fill = "Clone size"  # Change legend title
    ) +
    theme_minimal() +
    scale_fill_manual(values = clono.col) + # Drops unused categories from the legend
    theme_custom(base_size = 10)  # Apply the general theme
  print(plot_clone_size_absolute)

}

```


<br>

```{r}
#| label: VDJ-metric-B-cell-clonotypes-relatives
#| fig-cap: "Relative number of clonotypes per sample, categorized by expansion levels (e.g., hyperexpanded, large, medium, small, single)."
#| echo: false
#| warning: false
#| eval: !expr (!is.null(meta_data))
#| fig-height: 4

if (flags$VDJB){
  clone_size_counts <- meta_data_filtered %>%
    group_by(orig.ident, cloneSize) %>%
    summarise(count = n_distinct(CTstrict), .groups = 'drop')  # Count unique clonotypes

  # Calculate percentages within each sample
  clone_size_percent <- clone_size_counts %>%
    group_by(orig.ident) %>%
    mutate(percentage = (count / sum(count)) * 100)

  plot_clone_size_percentage <- ggplot(clone_size_percent, aes(x = orig.ident, y = percentage, fill = cloneSize)) +
    geom_bar(stat = "identity") +  # Stacked bars with proportion scaling
    scale_y_continuous(labels = scales::percent_format(scale = 1)) +  # Convert to percentage
    scale_fill_manual(values = clono.col) +  # Use predefined colors
    labs(x = "Sample",
        y = "Percentage of Cells",
        fill = "Clone Size") +
    theme_minimal() +
    theme_custom(base_size = 10)  # Apply the general theme

  print(plot_clone_size_percentage)
}
```


:::
